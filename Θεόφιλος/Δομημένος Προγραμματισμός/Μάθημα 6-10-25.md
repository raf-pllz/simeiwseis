Στο `printf`  όταν πας να εκτυπώσεις μεταβλητές με τύπο `double` `long double` πρέπει να χρησιμποιείς το ανάλογο χαρακτήρα στο `%`

Δηλαδή:
`float` -> `%f`
`double` -> `%lf`
`long double` -> `%Lf`

(Παρόλα αυτά, για τον μεταγλωττιστή `gcc` φαίνεται πως για το float και για το double μπορεί να χρησιμποιηθεί ο ίδιος προσδιοριστής, δηλ. `%lf` = `%f`)

Ομοίως και με τους ακέραιους αριθμούς πρέπει:

`short` -> `%hd`
`int` -> `%d`
`long int` -> `%ld`
`unsigned int` -> `%ud` 

(Παρόλα αυτά, για τον μεταγλωττιστή `gcc` φαίνεται πως για το short, int, unsigned μπορεί να χρησιμποιηθεί ο ίδιος προσδιοριστής, δηλ. το `%d` επαρκεί. Όμως, δεν βγαίνει `error`, βγαίνει `warning`)

Για τα windows, για την υποστήριξει των ελληικών χαρακτηρών πρέπει να γράψω σε μια γραμμή, (για το dev-C++).

```
system("chcp 1253");
```

Για την εκχώρηση χαρακτηρών σε μεταβλητές μπορείς επίσης να "βάλεις" αριθμούς που αντιστοιχούν στους ανάλογους χαρακτήρες από τον πίνακα ASCII. 

`%e` ->  1.234568e-001 -> $1.234568 \cdot 10^1$

Άμα θέλουμε να ελέγξουμε πόσους αριθμούς θέλω  να εμφανίσω στο τερματικό, τότε:
στον προσδιοριστή κάνω το παρακάτω.

Για `float` -> `%.4f` -> 0.1234
Το ίδιο και για τον εκθέτη `double` -> `%.6e` -> 0.123456e-001

`\t` = ~7 tabs

## [Χ] ΑΣΚΗΣΟΥΛΑ:
`boolean` για να μπορώ να κάνω `printf`.
Απάντηση: 
`%d` καθώς η C μετατρέπει την μεταβλητή με τύπο `boolean` σε ακέραιο αριθμό. Άρα το αποτέλεσμα θα είναι ακέραιος αριθμός. Ο προσδιοριστής `%b` είναι για binary output. 

## [Χ] ΝΑ ΨΑΞΕΙΣ:

- Τι είναι το `block` στην `C`;

	- Απάντηση: το `block` αναφέρεται στο `scope` των άγκιστρων

- Γιατί μπορώ να γράψω μόνο ένα προσδιοριστές για να κάνω print όλους τους απλούς ακεραίους;

	- Απάντηση: Παρόλο που το επιτρέπει δεν ειναι ασφαλές και σωστό, καθώς στην περίπτωση που φτιάξουμε μια μεταβλητή με τιμή `0xFFFFFFFF` τότε το αποτέλεσμα από τον προσδιοριστή θα είναι -1, καθώς ο μεταγλωττιστλης θα μετατρέψει την μεταβλητή μας σε ακέραιο αριθμό, κάτι που δεν είναι.